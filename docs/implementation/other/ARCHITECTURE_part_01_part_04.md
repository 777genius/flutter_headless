## Monorepo архитектура (feature-first + DDD + SOLID) (part 1) (part 4)

Back: [Index](./ARCHITECTURE_part_01.md)

- **Anti-patterns**: 3–5 “нельзя”.

**Когда обновлять:**
- Любое изменение публичного API, инвариантов, или поведения по умолчанию пакета → **обновляем `LLM.txt` в том же PR**.

### Типовые кейсы (куда класть код, чтобы не нарушать границы)

Ниже — ситуации, которые возникают почти всегда. Цель: не допускать связей **компонент → компонент**, но при этом не терять удобство и переиспользование.

#### Кейс 1: “Dialog хочет Button” (не делаем `dialog -> button`)

- **Антипаттерн**: dialog‑компонент импортит `headless_button`, чтобы нарисовать actions.
- **Правильно**:
  - `Dialog` объявляет **parts/slots** (например `actions` как `Widget`/builder) в своём `presentation`.
  - Конкретное приложение/фасад решает, что передать в `actions` (хоть `RTextButton`, хоть любой другой виджет).
  - Если нужно единообразное расположение/отступы/поведение — это **семантические токены** (`tokens/semantic`) или **renderer** диалога, а не зависимость от кнопки.

#### Кейс 2: “DropdownButton хочет Dialog/Overlay” (не делаем `dropdown -> dialog`)

 - **Антипаттерн**: `DropdownButton` использует `RDialog` как “готовый попап”.
- **Правильно**:
  - Всё, что касается портала/позиционирования/барьеров/скролла/закрытия по клику снаружи — это `anchored_overlay_engine`.
  - `DropdownButton` использует overlay‑механизм напрямую.
  - `Dialog` тоже использует overlay‑механизм напрямую. Оба компонента становятся независимыми.

#### Кейс 3: “Несколько компонентов хотят одинаковую логику hover/pressed/focus”

- **Антипаттерн**: копируем обработчики в каждом `R*`.
- **Правильно**:
  - Общие политики интеракций — в `headless_foundation/interactions` и/или `state_resolution`.
  - Компоненты подключают общий механизм и подают свои входные сигналы (gesture/focus), а не реализуют всё заново.

#### Кейс 4: “Нужны единые правила приоритетов состояний” (pressed vs disabled vs focused)

- **Антипаттерн**: “как получилось” через `if` в каждом компоненте/теме.
- **Правильно**:
  - Правила приоритетов и комбинаций — централизованно в `headless_foundation/state_resolution`.
  - Тема/рендерер получает уже нормализованные состояния и ведёт себя предсказуемо (POLA).

#### Кейс 5: “Хотим общий визуальный паттерн: кнопки в диалоге выглядят так-то”

- **Антипаттерн**: жёстко прошиваем структуру и виджеты внутрь `Dialog`.
- **Правильно (headless)**:
  - Либо это **renderer диалога** (структура/раскладка/эффекты) + семантические токены.
  - Либо это решается **в приложении** композицией: передали нужные actions.

#### Кейс 6: “Пользователь не хочет 10 импортов”

- **Правильно**:
  - `packages/headless` (facade) ре‑экспортирует популярные компоненты и базовые контракты.
  - При этом компоненты остаются отдельными пакетами (можно подключать точечно).

#### Кейс 7: “Кажется, что нужен shared UI‑компонент (например, Divider/Label/Spinner)”

- **Проверка перед выносом**:
  - Это действительно “компонент”, или это часть рендера конкретной фичи?
- **Правило**:
  - Если это **чистый примитив/механизм** → `headless_foundation` или `headless_tokens`.
  - Если это **кусок конкретной структуры** → остаётся внутри фичи в renderer/parts.

---

### Порог выноса в `headless_foundation` (грамотное правило 2–3 фич)

`headless_foundation` — это **инфраструктурный слой**, который должен быть максимально стабильным. Ошибка, которую часто делают: кладут туда “общие куски UI” или “удобные компоненты”. Мы так не делаем.

#### Что такое “foundation” (а что нет)

- **Foundation = механизмы поведения** (cross-cutting):
  - overlay/portal/positioning (anchored_overlay_engine), dismiss, scroll strategies
  - focus management, focus trap, keyboard navigation policy
  - интеракции (pressed/hovered/focused) как политика, а не разметка
  - state resolution (приоритеты/нормализация состояний)
  - FSM primitives для сложных интерактивных паттернов
  - a11y-утилиты уровня “поведение/семантика”, не визуал

- **НЕ foundation**:
  - готовые визуальные виджеты/структуры (это renderer/parts внутри конкретной фичи)
  - “resolved style” модели конкретного компонента (любые `Resolved*`-типы, связанные с одним компонентом)
  - “кусок диалога” или “кусок селекта”, который нужен только одному компоненту
  - theme implementations (брендовые темы/рендереры)

#### Правило 2–3 фич (порог)

Используем 3 уровня решения:

- **Уровень A — остаётся в компоненте (default)**:
  - используется **в 1 компоненте**, или
  - это “структурный кусок” renderer/parts, или
  - механизм зависит от доменных типов конкретного компонента.

- **Уровень B — кандидат в foundation (2 фичи)**:
  - одинаковая логика/инварианты используются **минимум в 2 компонентах**, и
  - это именно **механизм поведения**, и
  - можно описать стабильный контракт без привязки к домену компонента.
  - Действие: выносим в foundation **только если** уже понятно, какие “ручки” расширения нужны (POLA).

- **Уровень C — обязателен foundation (3+ фичи)**:
  - механизм нужен **в 3+ компонентах** (или это очевидная платформа: overlay/anchoring, focus, state_resolution), и
  - повторение кода ведёт к расхождениям поведения.
  - Действие: выносим в foundation и фиксируем API/контракт.

#### Чеклист перед выносом (чтобы не “засорить foundation”)

Перед тем как вынести, отвечаем “да” на всё:

- **Механизм, не виджет**: это поведение/политика, а не разметка.
- **Нет доменной привязки**: не зависит от `ButtonSpec/DialogSpec/...`.
- **Чёткий контракт**: можно сформулировать входы/выходы и инварианты.
- **Тестируемость**: можно написать поведенческие тесты без golden.
- **POLA**: дефолты предсказуемы, нет скрытых сайд‑эффектов.

Если хотя бы один пункт “нет” — оставляем внутри компонента и возвращаемся позже.

---

### Политика версионирования (SemVer) для monorepo пакетов

Цель: не получить “матрицу совместимости” из десятков пакетов. Для дизайн‑систем это критично, потому что пользователям важнее **предсказуемость**, чем микро‑оптимизация релизов.

#### Рекомендация: lockstep‑версионирование для всех публичных пакетов

Мы держим **одну общую версию `X.Y.Z`** для:

- `headless_tokens`
- `headless_foundation`
- `headless_contracts`
- `headless_theme`
- `headless` (facade)
- всех `packages/components/headless_*`

Почему это правильно:

- Пользователь видит **одну версию системы**, а не “button@2.x + dialog@5.x + theme@1.x”.
- Снижается риск несовместимых комбинаций.
- Проще поддерживать документацию, примеры и миграции.

#### Правила SemVer (что считается patch/minor/major)

- **PATCH (`X.Y.Z+1`)**:
  - багфиксы, исправление документации, внутренние рефакторинги без изменения публичного API
  - правки производительности без изменения поведения по умолчанию

- **MINOR (`X.(Y+1).0`)**:
  - добавление новых возможностей **аддитивно** (новые компоненты, новые capabilities, новые токены)
  - новые опции/поля со значениями по умолчанию, которые сохраняют старое поведение (POLA)
  - новые renderer parts/slots без изменения текущих дефолтов

- **MAJOR (`(X+1).0.0`)**:
  - любое breaking change публичного API (сигнатуры, удаления, переименования)
  - изменение поведения по умолчанию, которое может “сломать ожидания”
  - удаление ранее deprecated API

#### Политика deprecation (чтобы миграции были спокойными)

- Любое планируемое удаление сначала помечается как deprecated.
- **Минимум 1 MINOR релиз** API живёт в deprecated‑состоянии.
- Удаление — только в **следующем MAJOR**.

Принцип: если пользователь обновился на новый minor — он должен получить предупреждение и время на миграцию, а не внезапный слом.

#### Совместимость зависимостей (инвариант)

- Компоненты и facade зависят от core‑пакетов в пределах **одного MAJOR**.
- Любой релиз `X.Y.Z` гарантирует, что все пакеты с версией `X.Y.Z` совместимы между собой.

#### Релизная дисциплина (минимальная, но строгая)

- Один релиз = один набор изменений во всех пакетах под одной версией.
- На каждый релиз:
  - короткий changelog (что добавили/починили/сломали)
  - если есть breaking — миграционные заметки

Это поддерживает POLA и снижает стоимость обновлений для пользователей библиотеки.

---

### Управление состоянием (state management) — что рекомендуем в Headless

Ключевой принцип: **Headless не навязывает пользователю стейтменеджер** (Riverpod/BLoC/MobX/Redux и т.д.).  
Наша задача как библиотеки — дать **универсальные контракты**, чтобы любой стейтменеджер мог управлять компонентами сверху.

#### 1) Controlled / Uncontrolled модель (как у Flutter `TextField`)

- **Controlled**: состояние приходит извне через `value/state` + `onChanged`.
- **Uncontrolled**: компонент хранит состояние внутри (если `controller/value` не переданы).
- **Правило POLA**: если передан controller/value — компонент не “перетирает” состояние сам.

Зачем: это позволяет “подключить” компонент к любому стейтменеджеру без форков.

#### 2) Controller-подход + `ValueListenable` как минимальный общий знаменатель

Для интерактивных компонентов (input/select/tabs и т.д.) лучший базовый контракт:

- controller объект (по смыслу как `TextEditingController`)
- наружу даём наблюдение через `ValueListenable<T>` / `Listenable`

Почему это “гугл-уровень”:

- 0 внешних зависимостей
- совместимо со всеми подходами (можно оборачивать в stream, mobx, riverpod, bloc)
- предсказуемый lifecycle: controller создаётся/передаётся/диспоузится по правилам

#### 3) Immutable State Object + события (events) для сложных компонентов

Для сложных штуковин (`Select/Combobox/Menu`):

- состояние описываем как **immutable state** (`copyWith`/паттерн матчинг)
- обновления происходят через **явные события** (open/close/select/highlight/blur…)
- внутри допускается FSM (см. `headless_foundation/fsm`) — но наружу всё равно выдаём “текущее состояние” и callbacks

Это снижает “магические” побочные эффекты и делает поведение тестируемым.

#### 3.1) Стандарт поведения для сложных компонентов (E1)

Для `Dialog`, `Select/Combobox` и menu‑подобных паттернов используем единый стандарт:

- **Events**: `sealed` события
- **State**: immutable state object
- **Reducer core**: `reduce(state, event) -> (nextState, effects)` (pure)
- **Effects**: отдельный слой побочных действий (overlay/focus/announce/reposition), чтобы ядро оставалось чистым

FSM допускается **поверх** этого стандарта (как режимы в state или как строгие правила переходов внутри reducer), но не вместо него.

Это также естественно соответствует UDF (Unidirectional Data Flow): **state вниз**, **events вверх** — что совпадает с актуальными рекомендациями Flutter app architecture и снижает риск “магических” сайд-эффектов.

#### 3.2) Async в E1 (политика v1)

- Reducer остаётся **pure**: никаких `Future` внутри `reduce`.
- Async делаем через **effects executor → result events**:
  - effect запускает операцию (с key/opId для дедупа/отмены),
  - по завершении executor диспатчит `Succeeded/Failed` события обратно в reducer.

#### 3.3) Effects / Overlay / Listbox — обязательные контракты v1

Чтобы избежать “Radix perf” и “overlay костылей”, фиксируем как требования v1:

- **Effects contract**: типизированные категории effects + executor с coalesce/dedupe/cancel + result events (см. `docs/V1_DECISIONS.md`).
- **Overlay SLA**: anchoring на scroll/resize, nested scroll, flip/shift/collision, обновления не чаще 1/frame (см. `docs/V1_DECISIONS.md`).
- **Listbox spec**: единые правила keyboard nav + typeahead (см. `docs/V1_DECISIONS.md`).
