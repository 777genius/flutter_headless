### Зачем вообще Headless, если можно “написать свои виджеты”?

Этот документ отвечает на вопрос: **почему Headless имеет смысл как библиотека**, даже если Flutter позволяет легко кастомизировать UI и писать свои компоненты.

Ссылки на связанные документы:
- `docs/MUST.md` — список ключевых улучшений и принципов.
- `docs/ARCHITECTURE.md` — целевая архитектура monorepo + DDD + SOLID.
- `docs/SPEC_V1.md` — спецификация для совместимых компонентов/пакетов.
- `docs/CONFORMANCE.md` — как заявлять Headless‑совместимость и минимальные проверки.

---

### Главная мысль

**Headless — это не “набор кнопок”.**  
Headless — это **система контрактов и механизмов**, которая позволяет:

- держать **единое поведение** и **единый язык дизайна** на масштабе команды/продукта,
- менять визуал/бренд **без форков и копипасты**,
- избегать “магии” и неожиданных эффектов (POLA),
- проверять корректность через тесты поведения, а не пиксели.

Писать кастомные виджеты можно всегда. Вопрос в том, **какова цена поддержки** и **насколько предсказуемой** останется система через 6–12 месяцев.

---

### Какие реальные проблемы решает Headless

#### 1) Согласованность UI на масштабе

Когда каждый пишет “свои” виджеты, быстро появляются расхождения:

- разные состояния (hover/pressed/focus/disabled) реализованы по‑разному,
- разные размеры/touch target,
- разные “правила” фокуса и клавиатуры,
- разные отступы и типографика,
- разные контракты (то `isLoading`, то `loading`, то отдельный `Spinner`).

Headless фиксирует **контракт** (variants/spec/state/resolved) и делает расхождения “сложнее случайно сделать”.

#### 2) Multi‑brand / white‑label без ветвления кода

“Кастомизировать виджет” в приложении часто заканчивается:

- `if (brand == ...)` внутри UI,
- дублирующимися компонентами `ButtonA/ButtonB`,
- копированием файлов “под бренд”.

Headless позволяет держать **один компонент** и менять:

- токены (raw + semantic),
- политику состояний,
- renderer (структуру/визуал),

не меняя бизнес‑код и не создавая параллельные реализации.

#### 3) POLA (Principle of Least Astonishment) как системное правило

В UI‑системе дорого не “нарисовать”, а “не удивлять”.

Headless закрепляет предсказуемость:

- controlled/uncontrolled модель (как у `TextField`),
- понятные дефолты (disabled/loading/focus),
- отсутствие скрытых сайд‑эффектов (не меняем фокус/не закрываем overlay “по магии”),
- единые правила приоритетов состояний.

#### 4) Сложные компоненты и “краевые” сценарии

Сложные интерактивные компоненты (`Select/Menu/Combobox/Dialog`) ломаются не в happy‑path, а на краях:

- фокус‑трап и возврат фокуса,
- клавиатурная навигация,
- закрытие по клику снаружи/esc,
- nested overlays,
- scroll/позиционирование,
- конкуренция событий (gesture vs focus vs dismiss).

Headless выносит общие механизмы в `foundation` (overlay/focus/FSM/state resolution), чтобы поведение было единообразным во всех компонентах.

#### 5) Тестируемость правильного уровня

В headless подходе критично проверять не пиксели, а **поведение**:

- переходы состояний,
- корректность callbacks,
- a11y семантику,
- клавиатурные сценарии,
- инварианты состояния.

Если каждый пишет свои виджеты “как получится”, тесты становятся разрозненными, а регрессии — неизбежными.

#### 6) API стабильность и масштабирование библиотеки

“Набор кастомных виджетов” обычно эволюционирует хаотично.

Headless (см. `docs/ARCHITECTURE.md`) делает ставку на:

- capability‑контракты (ISP) вместо одного гигантского интерфейса,
- renderer contracts для визуала,
- lockstep SemVer для пакетов monorepo,
- deprecation policy вместо внезапных breaking changes.

---

### Уроки из web-экосистемы (2025–2026), которые нам полезны

В web мире headless UI часто завязан на hooks/render‑props и упирается в server/client границы (например, React Server Components).  
В Flutter такого разрыва нет, но урок важен: **не строить core API на хрупких runtime‑механизмах**. Поэтому Headless фиксирует поведение через чистые контракты (events/state/effects) и renderer contracts, а не через “магические” паттерны.

---

### Что Headless НЕ делает (и почему это важно)

- **Не навязывает стейтменеджер** (Riverpod/BLoC/MobX) — библиотека должна быть совместима со всеми подходами.
- **Не навязывает DI** (`get_it/injectable/modularity_dart`) — DI остаётся на уровне приложения.
- **Не пытается быть “ещё одним Material”** — цель не “сделать набор готовых красивых компонентов”, а дать архитектуру для разных брендов и систем.

---

### DX сегодня (коротко)

Чтобы снизить порог входа без потери headless-архитектуры:
- есть **simple sugar** (`style: R*Style`) → компилируется в overrides,
- есть **theme defaults** (`MaterialHeadlessDefaults`) для общих политик,
- есть **Headless*Scope** для локальной подмены capability,
- документация разделена на Users/Contributors + golden path.

---

### Когда Headless не нужен (честно)

Headless может быть overkill, если:

- один бренд,
- небольшая команда,
- нет требований к a11y/keyboard/overlay‑сложности,
- UI меняется редко и не является продуктовой ценностью,
- вы не планируете поддерживать дизайн‑систему как библиотеку.

---

### Когда Headless особенно оправдан

Headless имеет максимальный ROI, если:

- 2+ бренда (white‑label) или разные продуктовые линии,
- несколько команд параллельно пилят UI,
- много сложных компонентов (select/menu/dialog),
- важны POLA и предсказуемое поведение,
- библиотека должна жить годами без “археологии” и переписываний.

---

### Практическая проверка: стоит ли это вашей команде

Если на большинство вопросов ответ “да” — Headless почти наверняка окупится:

- У нас регулярно расходятся реализации одинаковых компонентов.
- Мы уже делали копии “под бренд” или условные ветки по бренду.
- У нас часто бывают регрессии в состояниях/фокусе/оверлеях.
- Мы хотим выпускать новые компоненты быстрее и предсказуемее.
- Мы хотим архитектуру, где “правильный путь” проще, чем “случайный”.



